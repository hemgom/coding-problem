# 925. Long Pressed Name
키보드에 이름을 입력하는 중이다.  
가끔 키보드를 길게 누르면 문자가 한 번 이상 입력될 수 있다.  
입력해야 할 이름 `name`과 입력결과인 `typed`가 문자열로 주어질 때  
`typed`가 `name`일 가능성이 있다면 `true`를 없다면 `false`를 반환한다.  
(키보드로 인한 중복입력은 있을 수도 없을 수도 있다.)
### 입력제한
- 1 <= `name.length(), typed.length()` <= 1000
- `name`과 `typed`는 오직 `영소문자`로만 구성된다.
### 풀이핵심
- 키보드로 인한 중복입력을 염두해 두었을 때, `typed -> name`가 될 수 있는지 확인이 필요
- `typed`를 기준으로 생각해보면
  - `name`에 없는 문자를 가지고 있거나, 있는 문자를 가지고 있지 않다면 `false`
  - 순차적으로 구성 문자를 동일하게 가지고 있더라도 `name`에 비해 문자 개수가 적다면 `false`
### 문제풀이
1. 아래의 변수를 생성해 초기화하고 다음의 용도로 사용한다.
   - `nL` : `name`의 길이를 저장
   - `tL` : `typed`의 길이를 저장
   - `pN` : 현재 `name`의 포인터 위치(인덱스)를 저장, 초기값 `0`
   - `pT` : 현재 `typed`의 포인터 위치(인덱스)를 저장, 초기값 `0`
   - `prev` : 조건에 부합하는 이전 문자를 저장, 초기값 `' '`
     - `name`와 `typed`의 특정 문자가 다를 경우 `연속입력`인지를 구분짓기 위해 사용
2. `pN < nL` 그리고 `pT < tL`을 만족하는 동안 아래의 연산을 반복한다.
   - `n`과 `t`에 현재 포인터의 위치를 기준으로 각각 `name` `typed`의 문자를 저장
   - 만약 `t`와 `n`이 같을 경우
     - 두 문자는 조건에 부합하므로 `prev`에 저장
     - `pN`과 `pT`의 값을 `1` 증가시킴
     - 이후 다음 반복으로 넘어감
   - 만약 `t`와 `n`이 다를 경우
     - `prev`와 `t`를 비교해 다르다면 `false`를 반환한다.
       - `typed`가 `name`보다 필요 문자를 적게 가졌기 때문에
     - `pT`의 값을 `1` 증가시킨다.
3. `(2)`의 과정을 끝마쳤다면 `pT`와 `pN`이후로 `prev`와 다른 문자가 있는지 확인해야 한다.
   - `(2)`의 과정은 단순히 두 포인터를 움직여 두 문자열 중 하나의 문자열을 끝까지 탐색만 하기 때문에
   - 각각의 문자열을 반복문을 통해 `prev`와 다른 문자요소가 없는지 확인, 있다면 `false`반환
   - 단, `pT`와 `pN`은 마지막 탐색 위치에서 `+1`된 값이므로 `1`을 감소시켜 반복문에 사용하도록 한다.
     - 두 변수가 각각 `nL`과 `tL`보다 값이 작아야하기 때문에
4. 모든 과정을 맞쳤다면 `true`를 반환
### 문제출처
- [leetcode](https://leetcode.com/problems/long-pressed-name/)
### 태그
`포인터 활용` `중복 입력` `문자열(요소) 비교`