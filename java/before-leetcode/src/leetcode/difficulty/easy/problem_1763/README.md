# 1763. Longest Nice Substring
문자열 `s`에 포함된 모든 영문자의 `대문자`와 `소문자`를 가지면 좋은 문자열이다.  
예를 들어 `"abABB"`는 `'A'`와 `'a'`를 가지며, `'B'`와 `'b'`를 가지기 때문에 `niceSubstring`이다.  
`"abA"`는 `'b'`의 경우 `'B'`가 없기 때문에 조건을 만족하지 못한다.

문자열 `s`가 주어질 때, `s`의 `niceSubstring` 중 가장 긴 것을 반환한다.  
길이가 동일 할 경우 `s`에서 위치상 앞에 있는 부분 문자열을 반환한다.  
만약 충족하는 `niceSubstring`이 없을 경우 빈 문자열을 반환한다.
### 입력제한
- 1 <= `s.length()` <= 100
- `s`는 `영소문자` 그리고 `영대문자`로 구성될 수 있다.
### 풀이핵심
- `s` 중에 `대문자`, `소문자`를 모두 가지지 못한 영문자를 찾아 기준점으로 삼아 2개의 부분 문자열을 만든다.
### 문제풀이
1. `s`의 길이가 `2`미만이라면 애초에 조건을 충족하지 못하므로 `""`를 반환한다.
2. `s`의 문자들을 문자배열 `letters`에 저장한다.
   - `HashSet<Character> alphabet`에 `s`에 포함된 모든 문자를 중복없이 저장한다.
3. `s`의 특정 문자가 `l`이라고 할 때, 반대 크기의 문자가 s에 포함되어있는지 확인한다.
   - 조건을 충족 못하는 문자를 기준으로(문자는 제외) `substring1, substring2`로 나눈다.
   - 단, 각각의 부분 문자열을 `longestNiceSubstring()`에 넣어 재귀형식을 갖는다.
4. 결과적으로 `s`의 모든 문자가 `대소문자`를 가질 경우 `s`를 그대로 반환
   - 반대의 경우 문자를 제외한 `substring1,2` 중 긴 문자열을 반환한다.
### 문제출처
- [leetcode](https://leetcode.com/problems/longest-nice-substring/)
### 태그
`반복문` `재귀함수` `다시 한 번 풀어볼 문제` `toCharArray()` `continue`