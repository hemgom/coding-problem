# 2614. Prime In Diagonal
 `n × n`의 2차원 정수 배열 `nums`가 주어진다.  
행렬의 대각선 라인에 위치한 요소들 중에 `가장 큰 소수`를 찾아 반환한다.  
대각선에 소수가 없다면 `0`을 반환한다.  

※ 참고 : 정수 `i`가 있을 때 `1 ~ i` 범위내에 `1`과 `i`를 제외한 약수가 없다면 `i`는 소수이다.
### 입력제한
- 1 <= `nums.length` <= 300
- `nums.length == nums[i].length` 
- 1 <= `nums[i][j]` <= 4 * 10<sup>6</sup>
### 풀이핵심
- 2차원 배열을 `행렬 형식`으로 배치했을 때 대각선에 위치한 요소들에 대해 `소수`인지 확인한다.
  - 그러한 `소수`들 중 `가장 큰 수`를 반환한다.
### 문제풀이
1. 아래의 변수를 생성 및 초기화한다.
   - `rowA` : `\ `방향 대각선의 행 포인터, 초기값은 `0`
   - `rowB` : `/ `방향 대각선의 행 포인터, 초기값은 `nums.length - 1`
   - `valueA, valueB` : 각 포인터 위치의 `nums` 요소 값을 저장
   - `prime` : 반환 할 `가장 큰 소수`를 저장, 초기값은 `0`
2. `nums` 열의 개수 만큼 아래의 연산을 반복한다.
   - `valueA`에 `nums[rowA][i]`를 저장하고 `rowA`의 값을 `1` 증가시킨다.
   - `valueB`에 `nums[rowB][i]`를 저장하고 `rowB`의 값을 `1` 감소시킨다.
   - `valueA` `valueB`에 대해 각각 `checkPrime`을 호출한다.
     - `checkPrime` : 파라미터가 `소수`인지 확인한 결과를 반환한다.
       - `2 ~ n의 제곱근`의 범위에서 `n`의 약수가 있는지 확인한다.
     - `prime`에 `valueA` `valueB`와 `prime` 중 큰 값을 저장한다.
3. `(2)`의 과정을 모두 마쳤다면 `prime`을 반환한다.
### 문제출처
- [leetcode](https://leetcode.com/problems/prime-in-diagonal/)
### 태그
`최대 소수` `2차원 배열`