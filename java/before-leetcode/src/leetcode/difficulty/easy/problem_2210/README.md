# 2210. Count Hills and Valleys in an Array
정수 배열 `nums`가 주어진다. `nums[i]`와 같지 않으면서 `i`와 가장 가까운 좌우 요소들을 찾는다.  
- 요소들이 `nums[i]`보다 모두 작다면 인덱스 `i`는 `nums`에서 `언덕`이다.
- 요소들이 `nums[i]`보다 모두 크다면 인덱스 `i`는 `nums`에서 `계곡`이다.
- 만약 `nums[i]`가 언덕일 때 `nums[i] == nums[i+1]`라면 `nums[i+1]`는 언덕의 일부이다.
  - 계곡의 경우도 마찬가지

`nums`에 속한 계곡과 언덕의 수를 반환한다.
### 입력제한
- 3 <= `nums.length` <= 100
- 1 <= `nums[i]` <= 100
### 풀이핵심
- 같은 값의 연속된 언덕 또는 계곡인 경우 카운팅은 1개이다.
### 문제풀이
1. `nums`에서 요소를 읽어 같은 값이 연속되는 경우를 제거한다.
2. `unique`의 크기가 `3`보다 작으면 `0`을 반환한다.
   - 문제의 조건을 달성하려면 적어도 서로 다른 숫자가 3개가 `nums`에 존재해야함
   - 이 부분을 보장한다는게 문제에서 제외된 것 같음
3. 인덱스 범위 `[2,unique.size()]`에 대해 아래의 조건을 확인한다.
   - `nums[i]`보다 앞 뒤의 요소가 모두 작다면 `언덕`이므로 `count`를 `1`증가시킨다.
   - 앞 뒤의 요소가 모두 크다면 `계곡`이므로 `count`를 `1`증가시킨다.
4. `(3)`의 과정이 끝났다면 `count`를 반환한다.
### 문제출처
- [leetcode](https://leetcode.com/problems/count-hills-and-valleys-in-an-array/)
### 태그
`연속된 요소 중복 제거` `요소의 앞 뒤 값 비교`