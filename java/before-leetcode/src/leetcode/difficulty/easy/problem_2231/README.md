# 2231. Largest Number After Digit Swaps by Parity
양수 정수 `num`이 주어진다.  
`패리티`가 같은 두 자리 숫자를 바꿀 수 있다.(두 숫자가 모두 `홀수` 또는 `짝수`일 때 스왑 가능)  
횟수에 상관없이 스왑이 가능할 때, 만들 수 있는 가장 큰 정수를 반환한다. 
### 입력제한
- 1 <= `num` <= 10<sup>9</sup>
### 풀이핵심
- 결국 짝수/홀수 숫자가 각각 2개 이상 존재할 경우 내림차순으로 정렬이 가능하다.
  - 만약 `1`개라면 초기 위치에 그대로 숫자를 유지해야한다는 소리
- 위의 예외를 생각해야 하므로 `num`에 포함된 숫자를 `짝수` `홀수`로 분리
  - 분리된 숫자들은 내림차순 정렬이 되어 있어야함
  - `num`를 순차적으로 읽으면서 숫자가 짝수일 경우 `짝수`에서 값을 순차적으로 꺼냄
    - 물론 숫자가 홀수라면 `홀수`에서 값을 순차적으로 꺼냄
  - 이 방법을 쓰는 이유는 어처피 `홀수 숫자 - 홀수 숫자` `짝수 숫자 - 짝수 숫자`끼리 스왑을 할 수 있기 때문
### 문제풀이
1. `num`을 문자열로 변환 `n`에 저장한다.
   - `n`의 각 문자들을 정수로 변환한 뒤 `Integer[] nums`에 순차적으로 저장
2. 짝수/홀수 숫자를 저장할 리스트 `even` `odd`를 생성
   - `nums`의 요소를 `내림차순`으로 정렬
   - `nums`의 요소 `digit`가 짝수/홀수인지 식별한 후 `even`과 `odd`에 저장
     1. 짝수일 경우 : `even`에 저장 후 다음 반복으로 넘어감
     2. 홀수일 경우 : `odd`에 저장
3. 아래의 변수를 추가로 생성 및 초기화한다.
   - `result` : 위치를 스왑한 정수를 저장(반환), 초기값 `0`
   - `ten` : 각 자릿수에 곱해야할 `10`의 배수를 저장, 초기값 `1`
   - `evenIndex` : `even`에서 꺼내올 요소의 인덱스를 저장, 초기값 `even.size() - 1`
   - `oddIndex` : `odd`에서 꺼내올 요소의 인덱스를 저장, 초기값 `odd.size() - 1`
4. `n`의 마지막 문자부터 제일 앞의 문자까지 아래의 연산을 반복한다.
   - `nChar`에 `n`의 문자를 정수로 변한에 저장
   - `nChar`의 값에 따라 다음을 수행
     1. 짝수일 경우
        - `even`에서 `evenIndex`위치의 요소를 꺼내 `ten`을 곱한 값을 `result`에 더해 저장
     2. 홀수일 경우
        - `odd`에서 `oddIndex`위치의 요소를 꺼내 `ten`을 곱한 값을 `result`에 더해 저장
   - `ten`에 `10`을 곱해 저장
5. 모든 과정을 마쳤다면 `result`를 반환
### 문제출처
- [leetcode](https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/)
### 태그
`숫자 위치 변환` `Character.getNumericValue()` `Collections.reverseOrder()` `ArrayList` `Integer.toString()`