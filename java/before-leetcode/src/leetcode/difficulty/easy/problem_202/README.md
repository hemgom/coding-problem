# 202. Happy Number
정수 `n`이 행복한지 판단하는 알고리즘을 작성한다.  
`행복`의 기준은 아래의 조건을 충족하는 숫자이다.
- `n`은 양의 정수이며, `n`의 자리별 숫자를 제곱하고, 그 값을 더한다.
- `n`이 `1`이 될 때까지 위의 과정을 반복하거나 `1`을 포함하지 않는 사이클로 끝없이 반복한다.
- 반복 과정이 `1`로 끝나게 되면 `n`은 행복한 숫자이다.  

`n`이 행복한 숫자일 경우 `ture`를 반환한고 아닐 경우 `false`를 반환한다.
### 입력제한
- 1 <= `n` <= 2<sup>31</sup> - 1
### 풀이핵심
- 말이 복잡하지만 `n`의 각자리 수를 제곱한 후 더한 값을 `n`에 저장하는 걸 반복한다.
- 반복문의 종료되는 경우는 2가지가 있다.
  1. `n == 1` 되는 경우
  2. `n`의 연산 후 값의 종류에 `반복`을 확인 할 경우
### 문제풀이
1. `n`의 각 자리수의 제곱을 구해 더하는 `sumOfSquare(int n)`을 생성한다.
   - `n % 10`을 통해 자리수를 구해 `square`에 저장한다.
   - `square * square`를 `sum`과 더해 `sum`에 다시 저장해준다.
   - `n /= 10`을 통해 아직 연산하지 못한 자리수들을 `n`에 저장한다.
   - 해당 과정은 초기 `n`의 자리수만큼 반복한다.
2. `sumOfSquare(n)`의 결과를 `n`에 저장한다.
3. `while문`을 통해 아래의 과정을 반복한다.
   - `n`의 값이 `1`이 아니면서 `sums`에 저장되지 않은 값일 때 반복문을 수행한다.
   - `n`의 값을 `sums`에 추가한다.
   - `sumOfSquare(n)`을 수행 후 다시 `n`에 저장한다
4. `sum`의 값이 `1`과 같은지 확인 후 그 결과를 반환한다.
### 문제출처
- [leetcode](https://leetcode.com/problems/happy-number/)
### 태그
`반복문` `HashSet` `contains(Object o)`