# 문제 분석
세 가지의 정수 값 `n`, `a`, `b` 가 주어진다. `n` 은 대회에 참가한 모든 참가자의 인원 수이며 `a` 와 `b` 는 첫 라운드의 특정 플레이어의 번호이며 추가적으로 `b` 는 `a` 가 라이벌로 생각하는 플레이어이다. 이 세 값을 가지고 아래의 연산을 수행해 `a` 가 라이벌로 생각하는 `b` 와 몇 번째 라운드에서 만나게 되는지 찾아 반환한다.
1. 라운드 별로 `1` 부터 생존 플레이어의 수까지 순차적으로 번호가 매겨진다. 번호는 자연수이며 `1씩 증가` 한다.
2. 다음 라운드의 경우 번호는 `(1)` 의 경우와 같이 다시 매겨지게 된다.
3. 라운드 도중 `a` 와 `b` 플레이어가 대결하는 라운드를 찾았다면 해당 라운드 수를 반환한다.  
<br/><br/>

앞 번호부터 순차적으로 `2명씩` 묶여 대결을 하니 대결 그룹에 인덱스를 부여하는 방식으로 문제를 해결했다. `n = 8` 일 때를 예시로 들면
- `[1, 2], [3, 4], [5, 6], [7, 8]` 이 되고 각 그룹은 `1~4` 의 인덱스를 부여 받는 것이다.
- 인덱스의 경우 현재 번호가 짝수라면 `2` 로 나누어 구한 몫으로 부여했으며, 홀수라면 현재번호에 `1` 을 더해 `2` 로 나눈 몫을 부여했다.
- 그룹의 번호(인덱스)를 구하는 연산은 `findIndex(int)` 를 구현해 해당 메서드에서 수행하도록 했다.
<br/><br/>

이렇게 초기 그룹 인덱스 값을 구하고 `round` 에 현재 라운드 수를 저장하기 위해 `1` 로 초기화 했다. 이후에는 `a` 와 `b` 가 제일 늦게 만날수 있는 결승전의 인원이 `2명` 이므로 `n != 2` 의 조건식을 사용한 `while` 문으로 각 라운드에 대한 연산을 진행했다.
- 먼저 `a`, `b` 가 같은 그룹(인덱스 값)에 있다면 조건을 만족했으므로 반복문을 벗어나 `round` 에 저장된 값을 반환한다.
- 한 라운드 진행시 인원은 절반으로 줄기에 `n` 을 `2` 로 나눈 값을 `n` 에 저장했다.
- 라운드가 진행됬기에 `round` 값을 `1` 증가
- 라운드가 진행되어 번호를 다시 매겨야 하므로 `findIndex(int)` 를 사용해 새로운 그룹 번호(인덱스)를 부여한다.
<br/><br/>

## Constraints
- `n` 은 `2<sup>1</sup>` 이상 `2<sup>20</sup>` 이하인 자연수이다. (부전승이란 경우를 없애기 위해서)
- `a` 와 `b` 는 `n` 이하의 자연수이며 서로 같은 값을 가질 수 없다.
<br/><br/><br/>

# 풀이
```java
class Solution {
    public int solution(int n, int a, int b) {
        int indexA = findIndex(a);
        int indexB = findIndex(b);
        int round = 1;
        
        while (n != 2) {
            if (indexA == indexB) break;
            n /= 2;
            round++;
            indexA = findIndex(indexA);
            indexB = findIndex(indexB);
        }
        
        return round;
    }
    
    public int findIndex(int num) {
        if (num % 2 == 0) {
            return num / 2;
        }
        return (num+1) / 2;
    }
}
```
<br/><br/>

## 참조 문서
- [programmers - 예상 대진표](https://school.programmers.co.kr/learn/courses/30/lessons/12985)